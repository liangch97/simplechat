# SYSU Chat 技术细节详解（小白友好版）

> 给非技术背景或初级开发者的"从零看代码"笔记。包括基础概念、实际代码讲解、数据流示意、常见坑。

---

## 目录
1. 基础概念速查
2. HTTP 与 REST 到底是什么？
3. JSON 数据格式讲解
4. 数据库与 JDBC 怎么用？
5. 后端如何处理一个请求？（从头到尾）
6. SSE 实时推送怎么工作？
7. 前端如何收发数据？
8. 安全与鉴权怎么做？
9. 文件存储与读取怎么做？
10. 常见错误与排查

---

## 1. 基础概念速查

### 1.1 什么是"服务器"？
- **定义**：运行在某台电脑上的程序，24/7 开着，等待接收请求、处理后返回结果。
- **本项目**：Java 程序 `WebChatServer.java`，监听 `localhost:8080`，当你打开浏览器访问 `http://localhost:8080` 时，就是在请求这个服务器。
- **类比**：就像一个"小卖部"，你去敲门（发请求），老板看到了（服务器收到），给你拿东西（返回结果）。

### 1.2 什么是"HTTP"？
- **定义**：超文本传输协议（HyperText Transfer Protocol），浏览器与服务器之间的"对话规则"。
- **简单说**：你发请求给服务器时，必须按照 HTTP 规则格式化；服务器回复时，也必须按照规则格式化。
- **规则长什么样？**
  ```
  请求（你发给服务器）：
    GET /api/history?roomKey=24336064&limit=20 HTTP/1.1
    Host: localhost:8080
    Authorization: Bearer <token>
    Content-Type: application/json
    
    （请求体，如果有的话）
  
  响应（服务器回给你）：
    HTTP/1.1 200 OK
    Content-Type: application/json
    
    {"messages": [...], "count": 20}
  ```

### 1.3 什么是"REST"？
- **定义**：一种设计 API 的风格，用 HTTP 的 URL + Method 来表达"动作"。
- **常见 Methods（方法）**：
  - `GET`：查询数据（不改动）
  - `POST`：提交数据（增加新数据或执行操作）
  - `PUT`：更新数据（替换整个资源）
  - `DELETE`：删除数据
- **本项目例子**：
  ```
  GET    /api/history?roomKey=xxx         ← 查询历史消息
  POST   /send                            ← 发送一条新消息
  POST   /api/files/upload?roomKey=xxx    ← 上传一个文件
  GET    /api/files/download?roomKey=xxx  ← 下载一个文件
  POST   /api/files/delete                ← 删除一个文件
  GET    /api/files/quota?roomKey=xxx     ← 查询配额
  ```

### 1.4 什么是"JSON"？
- **定义**：一种轻量级的数据格式，方便在网络上传输，易于人读。
- **长什么样**：
  ```json
  {
    "name": "Alice",
    "age": 20,
    "messages": [
      {"id": 1, "text": "Hello"},
      {"id": 2, "text": "World"}
    ],
    "isOnline": true
  }
  ```
- **对比 XML**（老年人的格式，更啰嗦）：
  ```xml
  <user>
    <name>Alice</name>
    <age>20</age>
    <messages>
      <message><id>1</id><text>Hello</text></message>
      <message><id>2</id><text>World</text></message>
    </messages>
    <isOnline>true</isOnline>
  </user>
  ```

---

## 2. HTTP 与 REST 到底是什么？（实际例子）

### 2.1 用户登录的 HTTP 对话

**你在浏览器里点"登录"按钮，前端代码做这件事**：
```javascript
// 前端代码（web/js/chat.js 里有类似的）
fetch('http://localhost:8080/api/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    username: 'alice',
    password: 'mypassword123',
    secretKey: '24336064'
  })
});
```

**转换成 HTTP 请求格式**：
```
POST /api/login HTTP/1.1
Host: localhost:8080
Content-Type: application/json
Content-Length: 82

{"username":"alice","password":"mypassword123","secretKey":"24336064"}
```

**后端收到后（服务器 WebChatServer.java 里做这件事）**：
```java
// 伪代码，实际代码在 WebChatServer.java
if (request.getMethod().equals("POST") && request.getRequestURI().equals("/api/login")) {
    // 1. 解析 JSON 请求体
    String requestBody = readInputStream(request.getRequestBody());
    // requestBody = {"username":"alice","password":"mypassword123","secretKey":"24336064"}
    
    // 2. 调用 UserDao 查数据库
    UserDao userDao = new UserDao(dbConnection);
    User user = userDao.login(username, password);
    
    // 3. 生成 Token（签名后的凭证）
    String token = userDao.generateToken(user.id, user.username);
    
    // 4. 生成 JSON 响应
    String responseBody = "{\"token\":\"" + token + "\",\"nickname\":\"" + user.nickname + "\",\"isAdmin\":" + user.isAdmin + "}";
    
    // 5. 发送响应
    response.getHeaders().put("Content-Type", "application/json");
    response.sendResponseHeaders(200, responseBody.length());
    response.getResponseBody().write(responseBody.getBytes());
}
```

**后端发回的 HTTP 响应**：
```
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 120

{"token":"YWxpY2U6MjAyNTAxMDEwODMwMDA6YWJjZDEyMzQ=","nickname":"Alice","isAdmin":false}
```

**前端收到后**：
```javascript
// 继续前端代码
.then(response => response.json())  // 解析 JSON
.then(data => {
    console.log('登录成功！');
    localStorage.setItem('token', data.token);  // 保存 Token
    localStorage.setItem('nickname', data.nickname);
    // 跳转到聊天页面
});
```

---

## 3. JSON 数据格式讲解（对照代码）

### 3.1 简单例子

```json
{
  "id": 1,
  "nickname": "Alice",
  "message": "Hello, world!",
  "createdAt": "2025-01-10 10:30:00"
}
```

**对应的 Java 类**：
```java
public class Message {
    public long id;
    public String nickname;
    public String message;
    public String createdAt;
    
    public Message(long id, String nickname, String message, String createdAt) {
        this.id = id;
        this.nickname = nickname;
        this.message = message;
        this.createdAt = createdAt;
    }
}
```

### 3.2 数组（列表）

```json
{
  "total": 2,
  "messages": [
    {"id": 1, "nickname": "Alice", "message": "Hi"},
    {"id": 2, "nickname": "Bob", "message": "Hello"}
  ]
}
```

**对应的 Java**：
```java
List<Message> messages = new ArrayList<>();
messages.add(new Message(1, "Alice", "Hi", "..."));
messages.add(new Message(2, "Bob", "Hello", "..."));

// 手动拼 JSON（本项目这样做）
String json = "{\"total\": " + messages.size() + ", \"messages\": [";
for (int i = 0; i < messages.size(); i++) {
    Message m = messages.get(i);
    json += "{\"id\": " + m.id + ", \"nickname\": \"" + m.nickname + "\", ...}";
    if (i < messages.size() - 1) json += ",";
}
json += "]}";
```

### 3.3 嵌套对象

```json
{
  "user": {
    "id": 1,
    "username": "alice",
    "profile": {
      "nickname": "Alice",
      "avatar": "https://..."
    }
  },
  "messages": [...]
}
```

**查找数据的步骤**：
```javascript
// 前端 JavaScript 代码
const data = JSON.parse(responseBody);
const userId = data.user.id;           // → 1
const nickname = data.user.profile.nickname;  // → "Alice"
const msgCount = data.messages.length; // → 几条消息
```

---

## 4. 数据库与 JDBC 怎么用？

### 4.1 数据库长什么样？

**messages 表**（每一行是一条消息）：
```
id  | nickname | content        | room_key | created_at
----|----------|----------------|----------|------------------
1   | Alice    | Hello          | 24336064 | 2025-01-10 10:00:00
2   | Bob      | Hi Alice       | 24336064 | 2025-01-10 10:05:00
3   | Alice    | How are you?   | 24336064 | 2025-01-10 10:10:00
```

### 4.2 什么是 JDBC？

- **定义**：Java 里连接数据库的标准库。
- **做什么**：
  1. 连接数据库
  2. 发送 SQL 查询
  3. 解析结果
  4. 关闭连接

### 4.3 JDBC 代码实际例子（从项目里摘）

**从 MessageDao.java 简化提取**：

```java
// ============ 查询消息历史 ============
public List<Message> getMessages(String roomKey, int limit, int offset) throws SQLException {
    // 第 1 步：写 SQL 语句（问号是占位符，后面会填充值）
    String sql = "SELECT id, nickname, content, created_at FROM messages " +
                 "WHERE room_key = ? " +
                 "ORDER BY created_at DESC " +
                 "LIMIT ? OFFSET ?";
    
    // 第 2 步：创建 PreparedStatement（预编译语句，防止 SQL 注入）
    PreparedStatement stmt = conn.prepareStatement(sql);
    
    // 第 3 步：填充占位符的值
    stmt.setString(1, roomKey);    // 第 1 个 ? 填充为 roomKey
    stmt.setInt(2, limit);         // 第 2 个 ? 填充为 limit（20）
    stmt.setInt(3, offset);        // 第 3 个 ? 填充为 offset（0）
    
    // 第 4 步：执行查询，得到结果集
    ResultSet rs = stmt.executeQuery();
    
    // 第 5 步：逐行遍历结果集，组装成 List
    List<Message> result = new ArrayList<>();
    while (rs.next()) {
        long id = rs.getLong("id");                    // 从结果集读 id 列
        String nickname = rs.getString("nickname");    // 读 nickname 列
        String content = rs.getString("content");      // 读 content 列
        String createdAt = rs.getString("created_at"); // 读 created_at 列
        
        // 组装成 Message 对象
        result.add(new Message(id, nickname, content, createdAt));
    }
    
    // 第 6 步：关闭资源（释放数据库连接）
    rs.close();
    stmt.close();
    
    return result;
}

// ============ 写入一条消息 ============
public void insertMessage(String roomKey, String nickname, String content) throws SQLException {
    String sql = "INSERT INTO messages (nickname, content, room_key, created_at) VALUES (?, ?, ?, NOW())";
    
    PreparedStatement stmt = conn.prepareStatement(sql);
    stmt.setString(1, nickname);
    stmt.setString(2, content);
    stmt.setString(3, roomKey);
    
    stmt.executeUpdate();  // 不是 executeQuery，因为这是"改"操作，不是"查"操作
    
    stmt.close();
}
```

### 4.4 避免 SQL 注入的坑

**❌ 危险的写法**（字符串拼接）：
```java
// 不要这样做！
String username = request.getParameter("username");
String sql = "SELECT * FROM users WHERE username = '" + username + "'";
// 如果用户输入：' OR '1'='1
// SQL 就变成：SELECT * FROM users WHERE username = '' OR '1'='1'
// 这样就查出了所有用户！
```

**✅ 安全的写法**（PreparedStatement）：
```java
// 要这样做！
String sql = "SELECT * FROM users WHERE username = ?";
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, username);  // 自动转义，问号位置安全填充
```

---

## 5. 后端如何处理一个请求？（从头到尾）

### 5.1 一个完整的消息发送流程

**场景**：用户在聊天框输入"Hello"，点击"发送"。

#### 第一步：前端发送请求
```javascript
// web/js/chat.js 里的代码
fetch(apiUrl, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({
        name: 'Alice',
        message: 'Hello',
        roomKey: '24336064'
    })
});
```

#### 第二步：后端收到请求

**在 WebChatServer.java 里**：
```java
public class WebChatServer {
    public static void main(String[] args) throws Exception {
        // 创建 HTTP 服务器，监听 8080 端口
        HttpServer server = HttpServer.create(new InetSocketAddress(8080), 0);
        
        // 注册 /send 路由（处理发送消息）
        server.createContext("/send", new SendHandler());
        
        server.start();
        System.out.println("Server started on port 8080");
    }
}

// 处理 /send 请求的 Handler
class SendHandler implements HttpHandler {
    @Override
    public void handle(HttpExchange exchange) throws IOException {
        // 1. 检查请求方法
        if (!exchange.getRequestMethod().equals("POST")) {
            sendError(exchange, 405, "Method Not Allowed");
            return;
        }
        
        // 2. 读取请求体（JSON 数据）
        InputStream is = exchange.getRequestBody();
        String requestBody = new String(is.readAllBytes());
        // requestBody = {"name":"Alice","message":"Hello","roomKey":"24336064"}
        
        // 3. 简单解析 JSON（本项目手工解析，没用 JSON 库）
        String name = extractJsonField(requestBody, "name");         // → "Alice"
        String message = extractJsonField(requestBody, "message");   // → "Hello"
        String roomKey = extractJsonField(requestBody, "roomKey");   // → "24336064"
        
        // 4. 校验数据
        if (name == null || message == null || roomKey == null) {
            sendError(exchange, 400, "Missing fields");
            return;
        }
        
        // 5. 调用 DAO 写入数据库
        try {
            Connection conn = Db.getConnection(roomKey);  // 根据房间秘钥获取数据库连接
            MessageDao dao = new MessageDao(conn);
            dao.insertMessage(roomKey, name, message);    // 写入消息
            
            // 6. 广播给所有在线用户（SSE）
            broadcastToAllClients(new Message(name, message, roomKey));
            
            // 7. 返回成功响应
            sendResponse(exchange, 200, "{\"success\": true}");
        } catch (Exception e) {
            // 捕获异常，返回错误
            sendError(exchange, 500, "Database error: " + e.getMessage());
        }
    }
    
    // 辅助方法：发送 JSON 响应
    private void sendResponse(HttpExchange exchange, int statusCode, String body) throws IOException {
        exchange.getResponseHeaders().put("Content-Type", "application/json");
        exchange.getResponseHeaders().put("Access-Control-Allow-Origin", "*");
        exchange.sendResponseHeaders(statusCode, body.length());
        exchange.getResponseBody().write(body.getBytes());
        exchange.close();
    }
    
    private void sendError(HttpExchange exchange, int statusCode, String message) throws IOException {
        String body = "{\"error\": \"" + message + "\"}";
        sendResponse(exchange, statusCode, body);
    }
    
    // 简单的 JSON 字段提取（示意，实际更复杂）
    private String extractJsonField(String json, String fieldName) {
        // "name":"Alice" → 提取 Alice
        String pattern = "\"" + fieldName + "\":\"([^\"]+)\"";
        // ... 正则表达式匹配 ...
        return "Alice";  // 示意
    }
    
    // 广播到所有 SSE 连接的客户端
    private void broadcastToAllClients(Message msg) {
        for (SseClient client : connectedClients) {
            client.sendMessage(msg);
        }
    }
}
```

#### 第三步：前端收到响应
```javascript
// .then(...) 回调被触发
.then(response => response.json())
.then(data => {
    if (data.success) {
        console.log('消息发送成功！');
        // 清空输入框
        document.getElementById('messageInput').value = '';
    }
});
```

**流程图简化版**：
```
用户点"发送"
    ↓
前端 fetch POST /send (JSON)
    ↓
后端 SendHandler 收到
    ↓
解析 JSON，校验数据
    ↓
调用 MessageDao.insertMessage() 写库
    ↓
广播给所有在线用户（SSE）
    ↓
返回 {success: true}
    ↓
前端收到，清空输入框
    ↓
其他用户收到消息推送，自动更新聊天框
```

---

## 6. SSE 实时推送怎么工作？

### 6.1 什么是 SSE？

- **定义**：Server-Sent Events，"服务器发事件"。
- **原理**：建立一个长期的 HTTP 连接，服务器可以随时向浏览器发数据，浏览器收到后自动触发事件。
- **vs WebSocket**：SSE 单向（服务器→浏览器），WebSocket 双向（双方都能主动发）。

### 6.2 前端如何订阅 SSE

```javascript
// web/js/chat.js 里的代码

// 创建 EventSource 连接（打开一个长期通道）
const eventSource = new EventSource(
    `http://localhost:8080/events?roomKey=24336064&nickname=Alice`
);

// 监听普通消息事件
eventSource.onmessage = function(event) {
    const message = JSON.parse(event.data);
    console.log('收到消息：', message);
    // 在页面上显示消息
    displayMessage(message);
};

// 监听自定义事件（在线人数）
eventSource.addEventListener('online', function(event) {
    const onlineList = JSON.parse(event.data);
    console.log('当前在线用户：', onlineList);
    // 更新用户列表
    updateOnlineUsers(onlineList);
});

// 连接出错时
eventSource.onerror = function(error) {
    console.error('连接断开，准备重新连接...');
    eventSource.close();  // 关闭（浏览器会自动重连）
};
```

**对应的 HTML 结构**：
```html
<div id="messageList">
    <!-- 消息会被追加到这里 -->
</div>

<div id="onlineList">
    <!-- 在线用户列表 -->
</div>
```

### 6.3 后端如何推送消息

```java
// WebChatServer.java 里的 EventsHandler

class EventsHandler implements HttpHandler {
    // 保存所有连接的客户端
    private static Set<ClientConnection> connectedClients = new HashSet<>();
    
    @Override
    public void handle(HttpExchange exchange) throws IOException {
        // 1. 检查请求
        if (!exchange.getRequestMethod().equals("GET")) {
            sendError(exchange, 405, "Method Not Allowed");
            return;
        }
        
        // 2. 提取查询参数
        String query = exchange.getRequestURI().getQuery();
        String roomKey = extractParam(query, "roomKey");     // → "24336064"
        String nickname = extractParam(query, "nickname");   // → "Alice"
        
        // 3. 设置 SSE 响应头
        exchange.getResponseHeaders().put("Content-Type", "text/event-stream");      // 告诉浏览器这是流
        exchange.getResponseHeaders().put("Cache-Control", "no-cache");              // 禁用缓存
        exchange.getResponseHeaders().put("Connection", "keep-alive");               // 保持连接
        exchange.getResponseHeaders().put("Access-Control-Allow-Origin", "*");
        
        // 4. 发送 200 OK 开始流
        exchange.sendResponseHeaders(200, 0);  // 0 表示响应体长度未知（流式）
        
        // 5. 获取输出流（持续写入）
        OutputStream os = exchange.getResponseBody();
        
        // 6. 创建客户端连接对象，保存起来
        ClientConnection client = new ClientConnection(os, roomKey, nickname);
        connectedClients.add(client);
        
        System.out.println(nickname + " joined room " + roomKey);
        
        // 7. 定时发送心跳（保持连接活跃）
        Timer heartbeatTimer = new Timer();
        heartbeatTimer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                try {
                    // 发送心跳：data: <json>\n\n
                    String heartbeat = "data: {\"type\": \"heartbeat\"}\n\n";
                    os.write(heartbeat.getBytes());
                    os.flush();
                } catch (IOException e) {
                    // 连接断开，移除这个客户端
                    connectedClients.remove(client);
                    heartbeatTimer.cancel();
                }
            }
        }, 0, 30000);  // 每 30 秒发一次
        
        // 8. 当有新消息时，发送给这个客户端
        // （这部分由 SendHandler 调用 broadcastMessage 实现）
    }
    
    // 静态方法：广播消息给所有连接
    public static void broadcastMessage(String roomKey, String nickname, String content) {
        String messageJson = "{\"nickname\": \"" + nickname + "\", \"content\": \"" + content + "\"}";
        String sseMessage = "data: " + messageJson + "\n\n";  // SSE 格式
        
        for (ClientConnection client : connectedClients) {
            if (client.roomKey.equals(roomKey)) {  // 只发送给同一房间的用户
                try {
                    client.outputStream.write(sseMessage.getBytes());
                    client.outputStream.flush();
                } catch (IOException e) {
                    connectedClients.remove(client);  // 失败则移除
                }
            }
        }
    }
    
    // 广播在线用户列表
    public static void broadcastOnlineUsers(String roomKey) {
        List<String> onlineNicknames = new ArrayList<>();
        for (ClientConnection client : connectedClients) {
            if (client.roomKey.equals(roomKey)) {
                onlineNicknames.add(client.nickname);
            }
        }
        
        String usersJson = "[" + String.join(",", onlineNicknames.stream()
            .map(n -> "\"" + n + "\"").collect(Collectors.toList())) + "]";
        String sseMessage = "event: online\ndata: " + usersJson + "\n\n";  // 自定义事件
        
        for (ClientConnection client : connectedClients) {
            if (client.roomKey.equals(roomKey)) {
                try {
                    client.outputStream.write(sseMessage.getBytes());
                    client.outputStream.flush();
                } catch (IOException e) {
                    connectedClients.remove(client);
                }
            }
        }
    }
}

// 客户端连接对象
class ClientConnection {
    OutputStream outputStream;
    String roomKey;
    String nickname;
    
    ClientConnection(OutputStream os, String roomKey, String nickname) {
        this.outputStream = os;
        this.roomKey = roomKey;
        this.nickname = nickname;
    }
}
```

### 6.4 SSE 协议格式

```
// 服务器发送：
data: {"nickname": "Alice", "content": "Hello"}\n\n

// 浏览器收到，触发 onmessage 事件

---

// 自定义事件：
event: online\n
data: ["Alice", "Bob", "Charlie"]\n\n

// 浏览器收到，触发 addEventListener('online', ...) 的回调
```

---

## 7. 前端如何收发数据？

### 7.1 前端架构概览

```
web/
├── index.html           ← HTML 页面结构
├── js/
│   ├── config.js        ← 配置（开发/生产环境 API URL）
│   ├── chat.js          ← 聊天逻辑（登录、SSE、发送消息）
│   └── files.js         ← 文件逻辑（上传、下载、列表）
└── css/
    └── style.css        ← 样式
```

### 7.2 登录流程代码（web/js/chat.js 简化）

```javascript
// 第 1 步：点击登录按钮时
document.getElementById('loginBtn').addEventListener('click', function() {
    const username = document.getElementById('usernameInput').value;
    const password = document.getElementById('passwordInput').value;
    const roomKey = document.getElementById('roomKeyInput').value;
    
    // 第 2 步：调用后端 /api/login 接口
    fetch(CONFIG.getApiUrl('loginEndpoint'), {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            username: username,
            password: password,
            secretKey: roomKey
        })
    })
    // 第 3 步：处理响应
    .then(response => {
        if (!response.ok) throw new Error('登录失败');
        return response.json();
    })
    .then(data => {
        // data = {token: "...", nickname: "Alice", isAdmin: false}
        
        // 第 4 步：保存登录信息到浏览器本地存储
        localStorage.setItem('token', data.token);
        localStorage.setItem('nickname', data.nickname);
        localStorage.setItem('roomKey', roomKey);
        localStorage.setItem('isAdmin', data.isAdmin);
        
        // 第 5 步：隐藏登录层，显示聊天界面
        document.getElementById('loginLayer').style.display = 'none';
        document.getElementById('chatContainer').style.display = 'block';
        
        // 第 6 步：连接 SSE 实时流
        connectSSE(roomKey, data.nickname);
        
        // 第 7 步：加载聊天历史
        loadHistory(roomKey);
    })
    .catch(error => {
        alert('登录错误：' + error.message);
    });
});

// 辅助函数：连接 SSE
function connectSSE(roomKey, nickname) {
    const eventsUrl = CONFIG.getApiUrl('eventsEndpoint') + 
                      `?roomKey=${roomKey}&nickname=${nickname}`;
    
    const eventSource = new EventSource(eventsUrl);
    
    // 接收普通消息
    eventSource.onmessage = function(event) {
        const msg = JSON.parse(event.data);
        displayMessage(msg);  // 显示在页面上
    };
    
    // 接收在线用户列表
    eventSource.addEventListener('online', function(event) {
        const users = JSON.parse(event.data);
        updateUserList(users);  // 更新左侧用户列表
    });
}

// 辅助函数：发送消息
function sendMessage() {
    const messageText = document.getElementById('messageInput').value;
    const nickname = localStorage.getItem('nickname');
    const roomKey = localStorage.getItem('roomKey');
    
    fetch(CONFIG.getApiUrl('sendEndpoint'), {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            name: nickname,
            message: messageText,
            roomKey: roomKey
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            document.getElementById('messageInput').value = '';  // 清空输入框
        } else {
            alert('发送失败：' + data.error);
        }
    });
}

// 辅助函数：显示消息（生成 HTML 并插入页面）
function displayMessage(msg) {
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message';
    messageDiv.innerHTML = `
        <div class="message-author">${msg.nickname}</div>
        <div class="message-content">${msg.content}</div>
        <div class="message-time">${msg.createdAt}</div>
    `;
    document.getElementById('messageList').appendChild(messageDiv);
    
    // 自动滚动到最下方
    document.getElementById('messageList').scrollTop = document.getElementById('messageList').scrollHeight;
}
```

### 7.3 文件上传代码（web/js/files.js 简化）

```javascript
// 选择文件并上传
document.getElementById('fileInput').addEventListener('change', function(event) {
    const file = event.target.files[0];  // 用户选的文件
    const roomKey = localStorage.getItem('roomKey');
    const token = localStorage.getItem('token');
    
    // 创建 FormData 对象（用来上传二进制文件）
    const formData = new FormData();
    formData.append('file', file);  // 文件本身
    
    // 发送上传请求
    fetch(`http://localhost:8080/api/files/upload?roomKey=${roomKey}`, {
        method: 'POST',
        headers: {
            'Authorization': 'Bearer ' + token  // 需要鉴权
        },
        body: formData  // 二进制文件内容
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('上传成功！');
            loadFileList(roomKey);  // 重新加载文件列表
        } else {
            alert('上传失败：' + data.error);
        }
    });
});

// 下载文件
function downloadFile(fileId) {
    const roomKey = localStorage.getItem('roomKey');
    const token = localStorage.getItem('token');
    
    // 直接跳转到下载 URL
    window.location.href = 
        `http://localhost:8080/api/files/download?roomKey=${roomKey}&fileId=${fileId}`;
}
```

---

## 8. 安全与鉴权怎么做？

### 8.1 Token 鉴权流程

**第 1 步：用户登录，后端生成 Token**
```java
// UserDao.java 里的代码
public String generateToken(long userId, String username) {
    // Token 格式：userId:username:timestamp:signature
    long timestamp = System.currentTimeMillis() / 1000;  // 当前时间戳（秒）
    String payload = userId + ":" + username + ":" + timestamp;
    
    // 签名（用 SHA-256 + SECRET_KEY）
    String signature = calculateSHA256(payload + ":" + SECRET_KEY).substring(0, 8);
    
    // 拼接
    String token = userId + ":" + username + ":" + timestamp + ":" + signature;
    
    // Base64 编码（方便传输）
    return Base64.getEncoder().encodeToString(token.getBytes());
    // → "YWxpY2U6MjAyNTAxMDEwODozMzQ6YWJjZDEyMzQ="
}
```

**第 2 步：前端保存 Token，后续请求带上**
```javascript
// web/js/chat.js
const token = localStorage.getItem('token');  // 读取保存的 token

// 访问文件 API 时
fetch('http://localhost:8080/api/files/list', {
    method: 'GET',
    headers: {
        'Authorization': 'Bearer ' + token  // 放在请求头
    }
});
```

**第 3 步：后端校验 Token**
```java
// WebChatServer.java 里的代码
public boolean validateToken(String token) throws Exception {
    try {
        // Base64 解码
        String decoded = new String(Base64.getDecoder().decode(token));
        // → "1:alice:2025010108:abcd1234"
        
        String[] parts = decoded.split(":");
        long userId = Long.parseLong(parts[0]);
        String username = parts[1];
        long timestamp = Long.parseLong(parts[2]);
        String signature = parts[3];
        
        // 检查是否过期（24 小时 = 86400 秒）
        long now = System.currentTimeMillis() / 1000;
        if (now - timestamp > 86400) {
            return false;  // Token 已过期
        }
        
        // 验证签名
        String expectedPayload = userId + ":" + username + ":" + timestamp;
        String expectedSignature = calculateSHA256(expectedPayload + ":" + SECRET_KEY).substring(0, 8);
        
        if (!signature.equals(expectedSignature)) {
            return false;  // 签名不匹配，可能被篡改
        }
        
        return true;  // Token 有效
    } catch (Exception e) {
        return false;
    }
}
```

### 8.2 房间秘钥校验

```java
// Db.java
public static boolean isValidRoomKey(String roomKey) {
    // 白名单
    return roomKey.equals("24336064") ||   // simplechat
           roomKey.equals("061318");        // homechat
}

public static Connection getConnection(String roomKey) throws Exception {
    if (!isValidRoomKey(roomKey)) {
        throw new Exception("Invalid room key: " + roomKey);
    }
    
    // 根据房间秘钥选择数据库
    String databaseName;
    if (roomKey.equals("24336064")) {
        databaseName = "simplechat";
    } else if (roomKey.equals("061318")) {
        databaseName = "homechat";
    } else {
        throw new Exception("Unknown room key");
    }
    
    // 连接到对应的数据库
    String url = "jdbc:mysql://localhost:3306/" + databaseName + "?...";
    return DriverManager.getConnection(url, DB_USER, DB_PASSWORD);
}
```

### 8.3 文件名安全化

```java
// FileManager.java
public static String sanitizeFileName(String fileName) {
    // 移除危险字符
    fileName = fileName.replaceAll("[^a-zA-Z0-9._-]", "");
    
    // 防止路径遍历（../ 这种）
    if (fileName.contains("..")) {
        throw new Exception("Invalid file name");
    }
    
    // 生成安全的文件名：时间戳 + 原名
    long timestamp = System.currentTimeMillis();
    return timestamp + "_" + fileName;
    // → "1704877200000_document.pdf"
}
```

---

## 9. 文件存储与读取怎么做？

### 9.1 物理文件路径结构

```
storage/
├── room_24336064/           ← 房间 A（simplechat）
│   ├── user_1/              ← 用户 1
│   │   └── 1704877200000_document.pdf
│   ├── user_2/              ← 用户 2
│   │   ├── 1704877200001_image.jpg
│   │   └── folder_abc/
│   │       └── 1704877200002_notes.txt
│   └── user_3/
│
└── room_061318/             ← 房间 B（homechat）
    ├── user_5/
    │   └── 1704877200003_report.docx
    └── user_6/
```

### 9.2 文件上传代码（后端，FileDao.java）

```java
public void uploadFile(String roomKey, long userId, String originalFileName, 
                       InputStream fileData, long fileSize) throws Exception {
    // 1. 安全化文件名
    String safeFileName = sanitizeFileName(originalFileName);
    
    // 2. 生成物理路径
    String dirPath = "storage/room_" + roomKey + "/user_" + userId + "/";
    File dir = new File(dirPath);
    if (!dir.exists()) {
        dir.mkdirs();  // 自动创建目录
    }
    
    String filePath = dirPath + safeFileName;
    
    // 3. 写入文件到磁盘
    FileOutputStream fos = new FileOutputStream(filePath);
    byte[] buffer = new byte[1024];
    int bytesRead;
    while ((bytesRead = fileData.read(buffer)) != -1) {
        fos.write(buffer, 0, bytesRead);  // 循环读写
    }
    fos.close();
    
    // 4. 写入数据库记录
    String sql = "INSERT INTO user_files (room_key, user_id, file_name, " +
                 "original_name, file_size, file_path, upload_time) " +
                 "VALUES (?, ?, ?, ?, ?, ?, NOW())";
    
    PreparedStatement stmt = conn.prepareStatement(sql);
    stmt.setString(1, roomKey);
    stmt.setLong(2, userId);
    stmt.setString(3, safeFileName);
    stmt.setString(4, originalFileName);
    stmt.setLong(5, fileSize);
    stmt.setString(6, filePath);
    stmt.executeUpdate();
    stmt.close();
}
```

### 9.3 文件下载代码（后端，WebChatServer.java）

```java
class FilesDownloadHandler implements HttpHandler {
    @Override
    public void handle(HttpExchange exchange) throws IOException {
        if (!exchange.getRequestMethod().equals("GET")) {
            sendError(exchange, 405, "Not Allowed");
            return;
        }
        
        // 1. 提取参数
        String query = exchange.getRequestURI().getQuery();
        String roomKey = extractParam(query, "roomKey");
        String fileId = extractParam(query, "fileId");
        String token = extractAuthToken(exchange);
        
        // 2. 校验权限
        if (!validateToken(token)) {
            sendError(exchange, 401, "Unauthorized");
            return;
        }
        
        try {
            // 3. 从数据库查询文件记录
            Connection conn = Db.getConnection(roomKey);
            FileDao fileDao = new FileDao(conn);
            FileInfo file = fileDao.getFileById(fileId);
            
            if (file == null) {
                sendError(exchange, 404, "File not found");
                return;
            }
            
            // 4. 读取磁盘文件
            File physicalFile = new File(file.filePath);
            if (!physicalFile.exists()) {
                sendError(exchange, 404, "File not found on disk");
                return;
            }
            
            // 5. 设置响应头
            exchange.getResponseHeaders().put("Content-Type", "application/octet-stream");
            exchange.getResponseHeaders().put("Content-Disposition", 
                "attachment; filename=\"" + file.originalName + "\"");
            
            // 6. 发送文件内容
            long fileSize = physicalFile.length();
            exchange.sendResponseHeaders(200, fileSize);
            
            FileInputStream fis = new FileInputStream(physicalFile);
            OutputStream os = exchange.getResponseBody();
            byte[] buffer = new byte[8192];
            int bytesRead;
            while ((bytesRead = fis.read(buffer)) != -1) {
                os.write(buffer, 0, bytesRead);  // 循环发送
            }
            fis.close();
            os.close();
            
            // 7. 更新下载计数
            fileDao.incrementDownloadCount(fileId);
        } catch (Exception e) {
            sendError(exchange, 500, "Error: " + e.getMessage());
        }
    }
}
```

### 9.4 文件配额检查

```java
// FileDao.java
public boolean checkQuota(String roomKey, long fileSize) throws SQLException {
    // 获取房间配额信息
    String sql = "SELECT total_quota, used_quota FROM user_storage_quota " +
                 "WHERE room_key = ?";
    
    PreparedStatement stmt = conn.prepareStatement(sql);
    stmt.setString(1, roomKey);
    ResultSet rs = stmt.executeQuery();
    
    if (rs.next()) {
        long totalQuota = rs.getLong("total_quota");    // 100GB = 107374182400 字节
        long usedQuota = rs.getLong("used_quota");
        
        return (usedQuota + fileSize) <= totalQuota;  // 是否够空间
    }
    
    return false;
}
```

---

## 10. 常见错误与排查

### 10.1 "连接被拒绝" 错误

**症状**：访问 http://localhost:8080 时浏览器显示"无法访问此网站"。

**排查步骤**：
```powershell
# 1. 检查后端是否启动
tasklist | findstr "java"  # Windows；如果没看到 Java 进程，说明没启动

# 2. 查看后端是否监听了 8080 端口
netstat -ano | findstr ":8080"  # Windows

# 3. 检查防火墙是否阻止了（可关闭防火墙试试）

# 4. 查看后端启动日志（有没有异常）
# 在终端中可以看到"Server started on port 8080"
```

### 10.2 "数据库连接失败" 错误

**症状**：后端启动时崩溃，日志显示"Cannot connect to database"。

**排查步骤**：
```powershell
# 1. 检查 .env 文件配置是否正确
type .env  # 查看内容

# 示例：
# DB_URL=jdbc:mysql://localhost:3306/simplechat?...
# DB_USER=root
# DB_PASSWORD=mypassword

# 2. 检查 MySQL 是否启动
# 在 Windows 任务管理器里查看服务
# 或命令行：
mysql -u root -p  # 尝试登录，输入密码

# 3. 检查数据库是否存在
mysql -u root -p
> SHOW DATABASES;  # 看看有没有 simplechat 库

# 4. 检查建表脚本是否执行过
# 运行 scripts/schema.sql 和 scripts/file-storage-schema.sql
mysql -u root -p simplechat < scripts/schema.sql
```

### 10.3 "登录失败" 错误

**症状**：输入用户名密码后，页面显示"登录失败"。

**排查步骤**：
```javascript
// 1. 打开浏览器开发者工具（F12），查看网络请求
// Network 标签 → 看到 /api/login 请求
// → Response 里显示什么错误信息

// 2. 检查用户是否存在（后端日志）
// 或直接数据库查询：
// mysql> SELECT * FROM users;
```

### 10.4 "文件上传失败" 错误

**症状**：上传文件时显示"上传失败"。

**排查步骤**：
```javascript
// 1. 检查是否有 Authorization Token
console.log('Token:', localStorage.getItem('token'));

// 2. 检查响应中的错误信息
// 在浏览器 F12 → Network → /api/files/upload → Response

// 3. 检查磁盘空间
// Windows：右键 C: 盘 → 属性 → 查看可用空间

// 4. 检查 storage 目录权限
// storage/ 目录是否存在？是否有写入权限？
```

### 10.5 "消息没有实时推送" 错误

**症状**：发送消息后，其他客户端迟迟收不到。

**排查步骤**：
```javascript
// 1. 检查 SSE 连接是否建立
console.log('EventSource readyState:', eventSource.readyState);
// 0 = 连接中，1 = 已连接，2 = 已关闭

// 2. 检查房间秘钥是否一致（两个客户端的 roomKey 要一样）
console.log('RoomKey:', localStorage.getItem('roomKey'));

// 3. 查看网络日志（F12 → Network）
// /events?roomKey=24336064&nickname=Alice 请求是否一直开着？

// 4. 查看浏览器控制台有没有 JavaScript 错误（Console 标签）
```

---

## 附：快速参考表

| 概念 | 说明 | 例子 |
|------|------|------|
| HTTP GET | 查询（读） | `GET /api/history?roomKey=24336064` |
| HTTP POST | 提交（增加/改） | `POST /send` with JSON body |
| JSON | 数据格式 | `{"name": "Alice", "age": 20}` |
| JDBC | Java 连接数据库 | `Connection conn = DriverManager.getConnection(url)` |
| PreparedStatement | 防止 SQL 注入 | `stmt.setString(1, value)` |
| SSE | 服务器推送 | `EventSource('/events')` |
| Token | 登录凭证 | `Authorization: Bearer <token>` |
| DAO | 数据访问对象 | `MessageDao.insertMessage(...)` |
| 房间秘钥 | 区分不同聊天室 | `24336064` or `061318` |
| 配额 | 文件存储限制 | 100GB per room |

---

## 结语

这份文档的目的是让"非技术人员"也能理解项目的工作原理。关键是：
1. **理解数据流**：用户输入 → 前端 → 后端 → 数据库 → 推送回前端。
2. **掌握关键概念**：HTTP、JSON、SSE、Token、DAO。
3. **知道从哪里查代码**：什么功能看哪个文件。
4. **学会排查问题**：有问题时，逐步检查网络、日志、数据库。

有问题随时提问！
